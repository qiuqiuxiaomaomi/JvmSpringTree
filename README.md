# JVM

JVM内存模型
![](https://i.imgur.com/4yiXJ4K.png)

<pre>
展望Java技术的未来
   1）模块化
   2）混合语言
   3）多核并行
   5）语法丰富
   6）64位虚拟机
</pre>

<pre>
编译JDK
</pre>

![](https://i.imgur.com/bxBUH8D.jpg)

![](https://i.imgur.com/MhNKVKC.jpg)

<pre>
Java内存区域
   运行时数据区域
	   1）程序计数器
          程序计数器是一块较小的内存空间，它可以看做是当前线程所有执行的字节码的行号指示器。字节码计时器的工作就是通过改变这个计数器的值来选取下一条徐亚哟执行的字节码指令，分支，循环，跳转，异常处理。
          每个线程都有自己独立的程序计数器
              1）如果当前正在执行的是一个java方法，这个计数器记录的就是正在执行的字节码指令的地址
              2）如果正在执行的是native方法，那么程序计数器值则为Undefined 

	   2）Java虚拟机栈
          每个线程都有自己独立的Java虚拟机栈,生命周期与线程相同
          异常情况
              1）如果线程请求的栈深度大于虚拟机所允许的深度，将跑出StackOverflowError
              2）如果虚拟机栈可以动态扩展，如果扩展无法申请到足够的内存，就会抛出OutOfMemoryError

	   3）本地方法栈

	   5）Java堆
          Java堆是被所有线程共享的区域,在虚拟机启动时创建。
          所有的对象，数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致了一些微妙的变化发生，所有的对象都分配在堆上也逐渐变得不是那么绝对了。

	   6）方法区
          方法区与JAVA堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息，常量，静态变量，及时编译后的代码等数据。Java规范将方法区描述为堆的一个逻辑部分。

	   7）运行时常量池
          运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

	   8）直接内存
          直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是会频繁的被程序使用。例如NIO，可直接在堆外分配内存。

    对象的创建
       jvm遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否
	   已经被加载，解析，初始化过，如果没有，那必须先执行相应的类加载过程
 
          在类加载检查通过后，接下来JVM将为新生对象分配内存，对象所需的内存大小在类加载完成之后便可确定，为对象分配空间等
       同于把一块确定大小的内存从JAVA堆中划分出来。
          1) 如果JAVA堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个
       指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间挪动一段与对象大小相等的距离，这种分配方式称之为指针碰撞
          2) 如果JAVA堆中内存并不是规整的，已经使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，JVM就必须维护一个列表,记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称之为空闲列表。

          选择哪一种分配方式由JAVA堆是否规整决定，而JAVA堆是否规整又由所采用的的垃圾收集器是是否带有压缩整理功能决定，因此，在使用Serial, Parnew等等Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于MARK-SWEEP算法收集器时，通常采用空闲列表。

          内存分配的原子性
          在并发情况下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又使用了原来的指针分配内存的情况
	      解决方案
             1）CAS配上重试机制保证更新操作的原子性
             2）把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在JAVA堆中预先分配一小块内存，称之为本地线程分配缓冲（TLAB），哪个线程要分配内存，就是在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。
   
          内存分配完成后，JVM需要将分配到的内存空间都初始化为0值，如果是TLAB这一工作可以提前到TLAB分配时进行。这一操作保证了对象的实例字段在JAVA代码中不赋值就直接使用，程序能访问到这些字段的数据类型所对应的0值。	

          对象的内存布局
            1）对象头
	           第一部分用于存放对象自身的运行时数据
		          1）hash码
			      2）GC分代年龄
                  3）锁状态标志
                  5）线程持有的锁
                  6）偏向线程ID
                  7）偏向时间戳
			      这部分称之为MARK WORD
		       第二部分是类型指针
		         即对象指向它的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针。
            2）实例数据
                 各种类型的字段内容，无论是父类继承下来的，还是子类自有的。
            3）对齐填充	
                 并不是必须的，HotSpot VM的内存管理系统要求内存管理系统要求对象的起始地址必须是8字节的整数倍。
    对象的访问定位
        1）使用句柄访问
        2）使用直接内存访问
        HotSpot采取第二种方式访问对象。

    生存还是死亡：
        即使在可达性算法中不可达的对象，也并非是非死不可的，这时候它们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次
        标记过程：
           如果对象在进行可达性分析后发现没有与GC ROOTS相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是次对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()方法已经被JVM调用过，虚拟机将这两种情况都视为"没有必要执行

    "方法区回收"
        在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以进行一次垃圾收集一般可以回收70%-95%的空间，而永久代的垃圾收集效率比较低。

    永久代的垃圾收集主要回收两部内容：
        1）废弃常量
        2）无用的类
	       1）该类所有的实例都已经回收，也就是JAVA堆中不存在该类的任何实例
		   2）加载该类的ClassLoader已经被回收
		   3）该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

    Hotspot
       1) HotSpot虚拟机对象
          OutOfMemory异常
       1）Java堆溢出
       2）虚拟机栈和本地方法栈溢出
       3）方法区和运行时常量池溢出
       5）本机直接内存溢出
</pre>
<pre>
垃圾收集器
   1）对象已死判断
       1）引用计数算法
          引用计数法，目前微软的COM，Python，Sequirrel都在用这种方式管理内存
          缺陷：
             很难解决对象之间循环引用的问题

       2）可达性分析算法
          目前主流的商用程序语言的主流实现都是使用可达性分析来判定对象是否存活的。这个算法的基本思想是通过一系列的称为"GC ROOTS"
       的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC ROOTS没有任何的引用链时，则证明这个对象是不可达的。

       GC ROOTS的对象包括：
         1）虚拟机栈（栈帧中的本地变量表）中引用的对象
	     2）方法区中类静态属性引用的对象
	     3）方法区中常量引用的对象
	     5）本地方法中JNI引用的对象。
       
       引用的分类
	    1）强引用
		    类似于 Object obj = new Object()
		2）软引用
	        用来描述一些还有用但并非必须的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常前，将会把这些对象列入
	    回收范围之中进行第二次回收，如果这次回收还是没有足够的内存才会跑出内存溢出异常。
	    3）弱引用
	        弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当
	    垃圾收集器工作时，不管当前内存是否足够，都会回收掉弱引用关联的对象。
	    5）虚引用
	        虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。
	    为一个对象设置为虚引用关联的唯一目的就是能在这个对象呗收集器回收的时候收到一个系统通知。

   2）垃圾收集算法
       1）标记清除算法
       2）复制算法
       3）标记整理算法
       5）分代收集算法
   3）垃圾收集器
       1）Serial收集器
       2）Parnew收集器
       3）Parallel Scavenge收集器
       5）Serial Old收集器
       6）Parallel Old收集器
       7）CMS收集器 
       8）G1收集器
       9）GC日志分析
       10）垃圾收集器参数分析
    5）内存分配与回收策略
       对象优先在Eden区分配
       大对象直接进入老年代
       长期存活的对象直接进入老年代
       动态对象年龄判断   
</pre>

<pre>
虚拟机性能监控与故障处理工具
    1）jps
    2) jstat
    3) jinfo
    5) jmap
    6) jhat
    7) jstack
    8) jconsole
</pre>

<pre>
调优案例分析
</pre>

<pre>
  1) Class文件结构
  2) 字节码指令
</pre>


<pre>
类的加载机制
  1）加载
  2）验证
  3）准备
  5) 解析
  6）初始化
类加载的双亲委派机制
</pre>

<pre>
程序编译与代码优化
</pre>

<pre>
Java的内存模型与线程
   1）线程的实现
   2）线程调度
   3）状态转换
</pre>

<pre>
线程安全与锁优化
</pre>