# JVM

JVM内存模型
![](https://i.imgur.com/4yiXJ4K.png)

<pre>
展望Java技术的未来
   1）模块化
   2）混合语言
   3）多核并行
   5）语法丰富
   6）64位虚拟机
</pre>

<pre>
编译JDK
</pre>

<pre>
Java内存区域
   运行时数据区域
	   1）程序计数器
          程序计数器是一块较小的内存空间，它可以看做是当前线程所有执行的字节码的行号指示器。字节码计时器的工作就是通过改变这个计数器的值来选取下一条徐亚哟执行的字节码指令，分支，循环，跳转，异常处理。
          每个线程都有自己独立的程序计数器
              1）如果当前正在执行的是一个java方法，这个计数器记录的就是正在执行的字节码指令的地址
              2）如果正在执行的是native方法，那么程序计数器值则为Undefined 

	   2）Java虚拟机栈
          每个线程都有自己独立的Java虚拟机栈,生命周期与线程相同
          异常情况
              1）如果线程请求的栈深度大于虚拟机所允许的深度，将跑出StackOverflowError
              2）如果虚拟机栈可以动态扩展，如果扩展无法申请到足够的内存，就会抛出OutOfMemoryError

	   3）本地方法栈

	   5）Java堆
          Java堆是被所有线程共享的区域,在虚拟机启动时创建。
          所有的对象，数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配，标量替换优化技术将会导致了一些微妙的变化发生，所有的对象都分配在堆上也逐渐变得不是那么绝对了。

	   6）方法区
          方法区与JAVA堆一样，是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息，常量，静态变量，及时编译后的代码等数据。Java规范将方法区描述为堆的一个逻辑部分。

	   7）运行时常量池
          运行时常量池是方法区的一部分，Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的
各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

	   8）直接内存
    Hotspot
       1) HotSpot虚拟机对象
    OutOfMemory异常
       1）Java堆溢出
       2）虚拟机栈和本地方法栈溢出
       3）方法区和运行时常量池溢出
       5）本机直接内存溢出
</pre>
<pre>
垃圾收集器
   1）对象已死判断
       1）引用计数算法
       2）可达性分析算法
   2）垃圾收集算法
       1）标记清除算法
       2）复制算法
       3）标记整理算法
       5）分代收集算法
   3）垃圾收集器
       1）Serial收集器
       2）Parnew收集器
       3）Parallel Scavenge收集器
       5）Serial Old收集器
       6）Parallel Old收集器
       7）CMS收集器 
       8）G1收集器
       9）GC日志分析
       10）垃圾收集器参数分析
    5）内存分配与回收策略
       对象优先在Eden区分配
       大对象直接进入老年代
       长期存活的对象直接进入老年代
       动态对象年龄判断   
</pre>

<pre>
虚拟机性能监控与故障处理工具
    1）jps
    2) jstat
    3) jinfo
    5) jmap
    6) jhat
    7) jstack
    8) jconsole
</pre>

<pre>
调优案例分析
</pre>

<pre>
  1) Class文件结构
  2) 字节码指令
</pre>


<pre>
类的加载机制
  1）加载
  2）验证
  3）准备
  5) 解析
  6）初始化
类加载的双亲委派机制
</pre>

<pre>
程序编译与代码优化
</pre>

<pre>
Java的内存模型与线程
   1）线程的实现
   2）线程调度
   3）状态转换
</pre>

<pre>
线程安全与锁优化
</pre>